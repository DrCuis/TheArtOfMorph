@node Design Morph by reuse
@chapter Design Morph by reuse

@*

In this chapter you will learn how to design new morph -- in the idea
of a new widget -- by assembling existing ones. This chapter will be
very familliar with the booklet @emph{Design GUI with Morph}, and it
is a good idea to read its @url{Layout
components,https://DrCuis.github.io/DesignGUI/Layout-components.html}
chapter before.


@node From where to start?
@section From where to start?

Design by reuse indeed, but from where to start? Which classes should
we make reuse from? As often, the @cuis{} system may be our best
guide, let's interrogate it to learn which morph has more subclasses.

We collect, for each existing morph in the @cuis{} system, the
quantity of subclasses, then we sort the result.

@smalltalkExample{| hallOfFame |
hallOfFame @assign{} Morph allSubclasses collect: [:each |
   Array with: each with: each subclasses size].
hallOfFame @assign{} hallOfFame sort: [:array1 :array2 | array1 second > array2 second]}

@figure{The hall of fame of morph subclasses count,ch02-hallOfFame,6}

Let's analyze some top ranked morphs:

@enumerate
@item
@class{PlacedMorph}. Its subclasses need to override the
@method{drawOn:} method. So not a candidate to design morph by reuse.

@item
@class{BorderedMorph}, @class{ColoredBoxMorph} and
@class{BoxMorph}. Those classes are @class{PlacedMorph} with a few
additional characteristics. Subclassing these classes will require
most of the time overriding the @method{drawOn:} method.

@item
@class{LayoutMorph}. It has 11 subclasses. It is designed to assemble
morphs in a new morph, using this class for reuse makes perfectly
sense and we already know how to use it.

@item
@class{SystemWindow}. As a view representing a whole application,
subclassing it makes sense to implement specific behaviors of one GUI
application, but not as a morph you can reuse as a widget. 

@item
@class{PluggableMorph}. It seems very generic, may be a good
candidate. It represents a view of an associated model, however its
subclasses need to implement a specific @method{drawOn:} method. We
may want to use it when designing a morph from scratch.

@item
@class{PluggableScrollPane}.

This morph encapsulates an arbitrary morph -- called a @emph{scroller}
-- in a pane with optional scrollbars when the scroller extent is too
large. It is very handy, and in some circumstances it makes sense to
subclass it.

@end enumerate

All in all, we have two candidates to subclass when conceiving a morph
by reuse: @class{LayoutMorph} and @class{PluggableScrollPane}.


@node Layout
@section Layout

Arranging a set of morphs is what does the @class{LayoutMorph} class,
therefore it makes sense to define a new morph based on layout then to
install a set of morphs into. This is exactly what does the
@class{LabelGroup} class of the @label{Cuis-Smalltalk-UI} package.

@subsection Arrange visually

This subclass of @class{LayoutMorph} takes a collection of textual
descriptions and morphs to arrange them in two columns of labels and
morphs. The idea is to give a label to widgets presented in a view.

@figure{A group of three morphs@comma{} each with its own
label,ch02-labelGroup,9}

In one layout column, the label group arranges nicely each label and
widget couple in a row so that all the label cells are of same
width. What it takes is a collection of label and morph
associations. The returned layout is to be added in a higher level
view.

@smalltalkMethod{LabelGroup class>>example1,
@return{} self with: @{
   'Name' -> (LabelMorph contents: 'send $25 for your name here').
   'Description which is very long...' -> (
      TextModelMorph withText: '' :: emptyTextDisplayMessage: 'Why Smalltalk?').
   'Smalltalk variants' -> (
      PluggableListMorph
         withModel: (ListModel with: #('Cuis-Smalltalk' 'Pharo' 'Squeak' 'Amber')) 
         listGetter: #list 
         indexGetter: #listIndex 
         indexSetter: #listIndex: ) @} ::
   color: Color white paler ;
   yourself}

The @class{LabelGroup} is a passive object, its only purpose is to
arrange visually morphs: all the user interactions are managed by the
widgets. However, in some circumstance, we want both to arrange
widgets and be notified about specific user interactions. This is what
does the @class{CheckGroup} and @class{RadioGroup} classes.

@subsection Be notified
As in @class{LabelGroup}, a @class{CheckGroup} presents a collection
of labels with associated widgets, here @class{CheckButtonMorph}.

In a @class{CheckGroup}, zero or more @class{CheckButtonMorph} can be
selected at once, contrary to a @class{RadioGroup} where only one
@class{RadioButtonMorph} is selected at once.

@figure{A check group to select among the baby squeaks,ch02-checkGroup,3}

Creating a check group only requires a collection of labels, or morphs:

@smalltalkMethod{CheckGroup class>>example1,
| group |
group := self fromList: #('Cuis-Smalltalk' 'Pharo' 'Squeak').
group buttons do: [:each | 
   each when: #checkSelection send: #show: to: Transcript].
@return{} group}

In the example, the @smalltalk{#checkSelection} event emitted by each
check button is captured for report purpose. The attentive reader will
observe this event is not specific to the check group. Indeed, the
check group itself emits another specific event
@smalltalk{#informCheckSelection} when a button is selected:

@smalltalkMethod{CheckGroup>>newSelection: radioButton,
" Inform we have a new selection "
self triggerEvent: #informCheckSelection with: (self symbolForButton: radioButton)}
	
The event is triggered with the button label as attribute. To observe
its use, read the method @smalltalk{CheckGroup class>>example2}.

@node Scroll pane
@section Scroll pane
