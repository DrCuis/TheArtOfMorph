@node Design from scratch
@chapter Design from scratch

When you imagine an unconventional way to interact with the computer,
it may indicate you are on the verge to design new morphs from
scratch: a new way to present information or/and to interact
with. This chapter will help you in that circumstances.

As we did in the previous chapter, we take a look at existing morphs
to learn from them, then we create our own morph.

@cindex morph @subentry @method{drawOn:}
@node A bit of introspection
@section A bit of introspection
Morphs implemented from scratch come with a @method{drawOn:} method to
produce its visual representation. We already met this method in the
@ref{Introduction}. Let's interrogate our running @cuis{} system to
analyze which morphs are involved:

@smalltalkExampleCaption{How many morphs implement drawing operations?,morphImplementDrawOn,
Morph allSubclasses size.
@result{} 155.

(Morph allSubclasses select: [:each | each selectors includes: #drawOn:]) size.
@result{} 69.}

We observe the majority of morphs are implemented by composing
existing morphs, this was the topic of the previous chapter. We want
to interrogate the @cuis{} system a bit further by considering the
line count of the @method{drawOn:} method of each morph.

@smalltalkExampleCaption{Line count of each @method{drawOn:},morphDrawOnLineCount,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount]}

@cindex tools @subentry object explorer
This script should be executed to open on an object explorer,
@kbd{Alt-Shift-I}.

Sadly, this result is not representative of the complexity of the
drawing operations. Indeed, well written Smalltalk code tends to span
over small & well factored methods. Nevertheless, the object explorer
let us quickly jump from one method to another.

To improve the exploring experience, we can go a bit further in our
previous script to present both the classes and the source codes of
the @method{drawOn:} methods:

@smalltalkExampleCaption{Tooling to review each @method{drawOn:},morphDrawOnViewer,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs := morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount].
morphs := morphs collect: [:each | each -> (each sourceCodeAt: #drawOn:)].
morphs explore.}

Once the code is executed, we have an object explorer to review
methods. The items at the top of the object explorer are with longer
@method{drawOn:} method:

@figure{Explorer of the draw methods,ch03-exploreDrawOn,14}

In this list, several items are @class{Sample***} classes, they are
examples found in the @label{Morphic-Examples} class category. They
demonstrate the capability of the @label{VectorGraphics} engine.

Let's take a look at @class{Sample01Cross} and its unique
@method{drawOn:} method:

@smalltalkMethod{drawOn: aCanvas,
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 100@@0 . 140@@0 . 140@@240 . 100@@240 . 100@@0 @} ].
   
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 0@@100 . 0@@140 . 240@@140 . 240@@100 . 0@@100 @} ]}

@figure{@class{Sample01Cross} shape with two rectangles,ch03-sampleStar1,3}

@exercise{Better looking shape,improvedCross, Edit the
@method{drawOn:} method to render a cross as shown in the image below
(@ref{ch03-sampleStar2}).}

@figure{A better looking cross,ch03-sampleStar2,3}

@cindex morph @subentry @acronym{SVG}
@cindex morph @subentry @class{AbstractVectorCanvas}
The method names involved in the code above will look familiar to
users acquainted to @acronym{SVG,Scalable Vector
Graphic}@footnote{@url{https://en.wikipedia.org/wiki/SVG}}. It is
indeed inspired by its specifications, and it may serve as a loose
reference@footnote{@url{https://www.w3.org/TR/SVG11/}}. Nevertheless,
your first reference to look at regarding the available drawing
operations is the @class{AbstractVectorCanvas} class then some bits of
its parent class, @class{MorphicCanvas}.

In this class, the methods are divided in two important categories:
the helper methods of the @label{drawing -} categories and the
fundamental Vector Graphics protocol in the @label{paths} &
@label{strokes} categories.

@figure{Method categories of the
@class{AbstractVectorCanvas},ch03-AbstractVectorCanvas,7}


In its @label{drawing - MorphicCanvas} category observe how its helper
method to draw a straight line relates to Vector Graphics engine:

@smalltalkMethod{line: pt1 to: pt2 width: morphStrokeWidth color: aStrokeColor,
self strokeWidth: morphStrokeWidth color: aStrokeColor do: [
   self moveTo: pt1.
   self lineTo: pt2 ]}

In the @method{strokeWidth:color:do:} method above, the argument of
the @smalltalk{do:} keyword is the path followed by the sketch, it
describes the outline of the shape to construct. It blends very nicely
in the Smalltalk syntax as a bloc of code. Your drawing operations
should always be presented in such a bloc. Of course, it can be
factored in several smaller methods or iterative processes, making it
a very powerful mean for drawing.

The @label{stroke & fill} method category shows the methods to adjust
the style of the path stroke. All in all, there are four categories of
parameters to play with:

@itemize
@item @strong{width.}
A float number representing the width of the line.

@item @strong{color.}
The color of the stroke, it's a @cuis{} @class{Color} instance.

@item @strong{foll color.}
The filling color, a @class{Color} instance.

@item @strong{dash style.}
There are three different parameters to play with to represent the
style of the line.

@end itemize

@c explain the width and point arguments are float
To be able to use floating numbers instead of integers, help to obtain
smoother visual rendering. To illustrate it, let's turn our simple
cross as a flashing medical cross as seen above the drugstore.

Let's rename the class and add a @smalltalk{width} attribute:

@smalltalkExample{PlacedMorph subclass: #MedicCross
   instanceVariableNames: 'width'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'ArtOfMorph'}

We initialize it properly:

@smalltalkMethod{initialize,
super initialize.
width := 0}

@c extend the cross to make it pulse in its width

@cindex morph @subentry step
@cindex morph @subentry animation

To make it pulse, we use the morphic's step mechanism.

@figure{A flashing medic cross,ch03-medicCross,3}
