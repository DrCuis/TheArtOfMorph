@node Design from scratch
@chapter Design from scratch

When you imagine an unconventional way to interact with the computer,
it may indicate you are on the verge to design new morphs from
scratch: a new way to present information or/and to interact
with. This chapter will help you in that circumstances.

As we did in the previous chapter, we take a look at existing morphs
to learn from them, then we create our own morph.

@cindex morph @subentry @method{drawOn:}
@node A bit of introspection
@section A bit of introspection
Morphs implemented from scratch come with a @method{drawOn:} method to
produce its visual representation. We already met this method in the
@ref{Introduction}. Let's interrogate our running @cuis{} system to
analyze which morphs are involved:

@smalltalkExampleCaption{How many morphs implement drawing operations?,morphImplementDrawOn,
Morph allSubclasses size.
@result{} 155.

(Morph allSubclasses select: [:each | each selectors includes: #drawOn:]) size.
@result{} 69.}

We observe the majority of morphs are implemented by composing
existing morphs, this was the topic of the previous chapter. We want
to interrogate the @cuis{} system a bit further by considering the
line count of the @method{drawOn:} method of each morph.

@smalltalkExampleCaption{Line count of each @method{drawOn:},morphDrawOnLineCount,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount]}

@cindex tools @subentry object explorer
This script should be executed to open on an object explorer,
@kbd{Alt-Shift-I}.

Sadly, this result is not representative of the complexity of the
drawing operations. Indeed, well written Smalltalk code tends to span
over small & well factored methods. Nevertheless, the object explorer
let us quickly jump from one method to another.

To improve the exploring experience, we can go a bit further in our
previous script to present both the classes and the source codes of
the @method{drawOn:} methods:

@smalltalkExampleCaption{Tooling to review each @method{drawOn:},morphDrawOnViewer,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs := morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount].
morphs := morphs collect: [:each | each -> (each sourceCodeAt: #drawOn:)].
morphs explore.}

Once the code is executed, we have an object explorer to review
methods. The items at the top of the object explorer are with longer
@method{drawOn:} method:

@figure{Explorer of the draw methods,ch03-exploreDrawOn,14}

In this list, several are named @class{Sample***}, they are examples
found in the @label{Morphic-Examples} class category. These classes
demonstrate the capability of the @label{VectorGraphics} engine.

Let's take a look at the @class{Sample01Cross} and its unique
@method{drawOn:} method:

@smalltalkMethod{drawOn: aCanvas,
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 100@@0 . 140@@0 . 140@@240 . 100@@240 . 100@@0 @} ].
   
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 0@@100 . 0@@140 . 240@@140 . 240@@100 . 0@@100 @} ]}

@figure{@class{Smaple01Cross} shape of two rectangles,ch03-sampleStar1,3}

@exercise{Better looking shape,improvedCross, Edit the
@method{drawOn:} method to render the cross as shown in the image
below.}

@figure{A better looking cross,ch03-sampleStar2,3}

@cindex morph @subentry @acronym{SVG}
@cindex morph @subentry @class{AbstractVectorCanvas}
The method names involved in the code above will look familiar to
users acquainted to @acronym{SVG,Scalable Vector
Graphic}@footnote{@url{https://en.wikipedia.org/wiki/SVG}}. It is
indeed inspired by its specifications, and it may serve as a loose
reference@footnote{@url{https://www.w3.org/TR/SVG11/}}. Nevertheless,
your first reference to look at regarding the available drawing
operations is the @class{AbstractVectorCanvas} class.

In this class, the methods are divided in two important categories:
the helper methods of the @label{drawing -} categories and the fundamental
methods in the @label{paths} & @label{strokes} categories.

@figure{Method categories of the
@class{AbstractVectorCanvas},ch03-AbstractVectorCanvas,7}
