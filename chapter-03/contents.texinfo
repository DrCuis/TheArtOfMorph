@node Design from scratch
@chapter Design from scratch

When you imagine an unconventional way to interact with the computer,
it may indicate you are on the verge to design new morphs from
scratch: a new way to present information or/and to interact
with. This chapter will help you in that circumstances.

As we did in the previous chapter, we take a look at existing morphs
to learn from them, then we create our own morph.

@menu
* A bit of introspection::
* Red to Medic cross::
@end menu

@cindex morph @subentry @method{drawOn:}
@node A bit of introspection
@section A bit of introspection
Morphs implemented from scratch come with a @method{drawOn:} method to
produce its visual representation. We already met this method in the
@ref{Introduction}. Let's interrogate our running @cuis{} system to
analyze which morphs are involved:

@smalltalkExampleCaption{How many morphs implement drawing operations?,morphImplementDrawOn,
Morph allSubclasses size.
@result{} 155.

(Morph allSubclasses select: [:each | each selectors includes: #drawOn:]) size.
@result{} 69.}

We observe the majority of morphs are implemented by composing
existing morphs, this was the topic of the previous chapter. We want
to interrogate the @cuis{} system a bit further by considering the
line count of the @method{drawOn:} method of each morph.

@smalltalkExampleCaption{Line count of each @method{drawOn:},morphDrawOnLineCount,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount]}

@cindex tools @subentry object explorer
This script should be executed to open on an object explorer,
@kbd{Alt-Shift-I}.

Sadly, this result is not representative of the complexity of the
drawing operations. Indeed, well written Smalltalk code tends to span
over small & well factored methods. Nevertheless, the object explorer
let us quickly jump from one method to another.

To improve the exploring experience, we can go a bit further in our
previous script to present both the classes and the source codes of
the @method{drawOn:} methods:

@smalltalkExampleCaption{Tooling to review each @method{drawOn:},morphDrawOnViewer,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs := morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount].
morphs := morphs collect: [:each | each -> (each sourceCodeAt: #drawOn:)].
morphs explore.}

Once the code is executed, we have an object explorer to review
methods. The items at the top of the object explorer are with longer
@method{drawOn:} method:

@figure{Explorer of the draw methods,ch03-exploreDrawOn,14}

In this list, several items are @class{Sample***} classes, they are
examples found in the @label{Morphic-Examples} class category. They
demonstrate the capability of the @label{VectorGraphics} engine.

@node Red to Medic cross
@section Red to Medic cross

Let's take a look at @class{Sample01Cross} and its unique
@method{drawOn:} method:

@smalltalkMethod{drawOn: aCanvas,
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 100@@0 . 140@@0 . 140@@240 . 100@@240 . 100@@0 @} ].
   
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
   aCanvas polyLine: @{ 0@@100 . 0@@140 . 240@@140 . 240@@100 . 0@@100 @} ]}

@figure{@class{Sample01Cross} shape with two rectangles,ch03-sampleStar1,3}

@exercise{Better looking shape,improvedCross, Edit the
@method{drawOn:} method to render a cross as shown in the image below
(@ref{ch03-sampleStar2}).}

@figure{A better looking cross,ch03-sampleStar2,3}

@cindex morph @subentry @acronym{SVG}
@cindex morph @subentry @class{AbstractVectorCanvas}
The method names involved in the code above will look familiar to
users acquainted to @acronym{SVG,Scalable Vector
Graphic}@footnote{@url{https://en.wikipedia.org/wiki/SVG}}. It is
indeed inspired by its specifications, and it may serve as a loose
reference@footnote{@url{https://www.w3.org/TR/SVG11/}}. Nevertheless,
your first reference to look at regarding the available drawing
operations is the @class{AbstractVectorCanvas} class then some bits of
its parent class, @class{MorphicCanvas}.

In this class, the methods are divided in two important categories:
the helper methods of the @label{drawing -} categories and the
fundamental Vector Graphics protocol in the @label{paths} &
@label{strokes} categories.

@figure{Method categories of the
@class{AbstractVectorCanvas},ch03-AbstractVectorCanvas,7}


In its @label{drawing - MorphicCanvas} category observe how its helper
method to draw a straight line relates to Vector Graphics engine:

@smalltalkMethod{line: pt1 to: pt2 width: morphStrokeWidth color: aStrokeColor,
self strokeWidth: morphStrokeWidth color: aStrokeColor do: [
   self moveTo: pt1.
   self lineTo: pt2 ]}

In the @method{strokeWidth:color:do:} method above, the argument of
the @smalltalk{do:} keyword is the path followed by the sketch, it
describes the outline of the shape to construct. It blends very nicely
in the Smalltalk syntax as a bloc of code. Your drawing operations
should always be presented in such a bloc. Of course, it can be
factored in several smaller methods or iterative processes, making it
a very powerful mean for drawing.

The @label{stroke & fill} method category shows the methods to adjust
the style of the path stroke. All in all, there are four categories of
parameters to play with:

@itemize
@item @strong{width.}
A float number representing the width of the line.

@item @strong{color.}
The color of the stroke, it's a @cuis{} @class{Color} instance.

@item @strong{foll color.}
The filling color, a @class{Color} instance.

@item @strong{dash style.}
There are three different parameters to play with to represent the
style of the line.

@end itemize

@c explain the width and point arguments are float
To be able to use floating numbers instead of integers, help to obtain
smoother visual rendering. To illustrate it, let's turn our simple
cross as a flashing medical cross as seen above the drugstore.

Let's rename the class and add a @smalltalk{width} attribute:

@smalltalkExample{PlacedMorph subclass: #MedicCross
   instanceVariableNames: 'width'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'ArtOfMorph'}

We initialize it properly:

@smalltalkMethod{initialize,
super initialize.
width := 0}

@c extend the cross to make it pulse in its width

@cindex morph @subentry step
@cindex morph @subentry animation

To pulse the cross, we use the morphic's step mechanism, generally
involving 3 methods: in our @class{MedicCross} the @method{step}
method is continuously executed at a period in milliseconds indicated
by its @method{stepTime} method,

@smalltalkMethod{CrossMedic >> stepTime,
@return 10 }

then, to indicate we want the stepping to occur, its
@method{wantsSteps} method must return @smalltalk{true},

@smalltalkMethod{CrossMedic >> wantsSteps,
@return true }

@exercise{@method{step} method makes it pulse,medicCrossStep,
Implement the @method{step} method in @class{MedicCross} so that its
@smalltalk{width} increments by 0.2 until 30@comma{} then it is zeroed.}

@figure{A flashing medic cross,ch03-medicCross,3}

In the next section we go a bit further by representing a real world
object, a simple ruler.

@node Ruler
@section Ruler

@cindex morph @subentry @class{PlacedMorph}
Rulers come with different width, our morph ruler is a
@class{PlacedMorph}@footnote{It can be grabbed and moved arround.}
with a @smalltalk{width} attribute:

@smalltalk{PlacedMorph subclass: #Ruler
instanceVariableNames: 'width'
classVariableNames: ''
poolDictionaries: ''
category: 'ArtOfMorph'}

Our ruler is to be graduated with metric unit, so we define our scale
between pixels and centimeters:

@smalltalkMethod{ppcm,
" pixels per cm "
^ 50.0}

To both ease reading of the graduations and to reveal as much as
possible the visuals underneath the ruler, it is painted in plain
color under the sticks and with transparency elsewhere.

@smalltalkMethod{drawOn: canvas,
| font extent |
font := FontFamily familyName: FontFamily defaultFamilyName pointSize: 8.
extent := width * self ppcm + (self ppcm / 2) @@ 60.
	
canvas fillRectangle: (-5 @@ 0 corner: extent x @@ 25) color: Color yellow.
canvas fillRectangle: (-5 @@ 25 corner: extent) color: (Color yellow alpha: 0.5).
canvas frameRectangle: (-5 @@ 0 corner: extent) borderWidth: 0.5
   color: Color yellow muchDarker .

canvas strokeWidth: 0.8 color: Color black do: [
   0 to: width do: [:posX |
      canvas moveTo: posX * self ppcm @ 0.5; lineToY: 10.
      canvas moveTo: posX * self ppcm + (self ppcm / 2) @@ 0.5 ; lineToY: 6] ].

0 to: width do: [:posX |
   canvas drawString: posX asString
      atCenterX: posX * self ppcm @@ 12 font: font color: Color black]}


@exercise{Avoid expensive calculus,avoidExpensiveCalculus, The
@method{drawOn:} method above is written to be compact and easy to
read; however the method @method{ppcm} is used extensively to convert
between centimeters and pixels@comma{} it implies numerous
multiplications and some divisions. These operations are more
expensive than additions. Rewrite @method{drawOn:} to avoid
multiplication and division@comma{} particularly in loops.}


@figure{Ruler with grad each centimeter,ch03-ruler1,7}


@exercise{Millimeter graduation,millimeterRuler,Our ruler should be graduated each millimeter as show in the figure below. Extend the @method{drawOn:} to do so.}

@figure{Ruler with a millimeter graduation,ch03-ruler2,7}
