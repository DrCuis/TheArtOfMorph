@node Design from scratch
@chapter Design from Scratch

@quotation
Simple things should be simple, complex things should be possible.
@author Alan Kay
@end quotation

When you imagine an unconventional way to interact with the computer,
it may indicate that you are on the verge of designing new morphs from
scratch: a new way to present information and/or to interact with it.
This chapter will help you in those circumstances. As we did in the
previous chapter, we will take a look at existing morphs to learn from
them, and then we will create our own morph.

@menu
* A bit of introspection::
* Red to Medic cross::
* Ruler::
@end menu

@cindex morph @subentry @method{drawOn:}

@node A bit of introspection
@section A Bit of Introspection

Morphs implemented from scratch come with a @method{drawOn:} method to
produce their visual representation. We already encountered this method
in the @ref{Introduction}. Let's interrogate our running @cuis{}
system to analyze which morphs are involved:

@cindex morph @subentry @method{drawOn:}

@smalltalkExampleCaption{How many morphs implement drawing operations?,
morphImplementDrawOn,
Morph allSubclasses size.
@result{} 155.
(Morph allSubclasses select: [:each | each selectors includes: #drawOn:]) size.
@result{} 69.}

We observe that the majority of morphs are implemented by composing
existing morphs, which was the topic of the previous chapter. We want
to interrogate the @cuis{} system a bit further by considering the line
count of the @method{drawOn:} method of each morph.

@smalltalkExampleCaption{Line count of each @method{drawOn:},
morphDrawOnLineCount,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount >
      (classB sourceCodeAt: #drawOn:) lineCount]}

@cindex tools @subentry object explorer

This script should be executed to open an object explorer,
@kbd{Alt-Shift-I}. Sadly, this result is not representative of the
complexity of the drawing operations. Indeed, well-written Smalltalk
code tends to span over small and well-factored methods. Nevertheless,
the object explorer lets us quickly jump from one method to another.

To improve the exploring experience, we can go a bit further in our
previous script to present both the classes and the source codes of
the @method{drawOn:} methods:

@smalltalkExampleCaption{Tooling to review each @method{drawOn:},
morphDrawOnViewer,
| morphs |
morphs := Morph allSubclasses select: [:each | each selectors includes: #drawOn:].
morphs := morphs sort: [:classA :classB |
   (classA sourceCodeAt: #drawOn:) lineCount > (classB sourceCodeAt: #drawOn:) lineCount].
morphs := morphs collect: [:each | each -> (each sourceCodeAt: #drawOn:)].
morphs explore.}

Once the code is executed, we have an object explorer to review
methods. The items at the top of the object explorer are those with
longer @method{drawOn:} methods:

@figure{Explorer of the draw methods,ch03-exploreDrawOn,14}

@cindex vector graphics

In this list, several items are @class{Sample***} classes; they are
examples found in the @label{Morphic-Examples} class category. They
demonstrate the capabilities of the @label{VectorGraphics} engine.

@node Red to Medic cross
@section Red to Medic Cross

Let's take a look at @class{Sample01Cross} and its unique
@method{drawOn:} method:

@smalltalkMethod{drawOn: aCanvas,
aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
aCanvas polyLine: @{ 100@@0 . 140@@0 . 140@@240 . 100@@240 . 100@@0 @} ].

aCanvas strokeWidth: 8 color: Color lightOrange fillColor: Color red do: [
aCanvas polyLine: @{ 0@@100 . 0@@140 . 240@@140 . 240@@100 . 0@@100 @} ]}

It produces a cross by drawing two red rectangles with an orange
border. The @method{polyLine:} method accepts an arbitrary number of
points to designate the summits of the polygon. We can improve how it
is rendered.

@figure{@class{Sample01Cross} shape with two rectangles,ch03-sampleStar1,3}

@exercise{Better looking shape,improvedCross,
Edit the @method{drawOn:} method to render a cross as shown in the
image below (@ref{ch03-sampleStar2}).
@figure{A better looking cross,ch03-sampleStar2,3}}

@cindex vector graphics @subentry @acronym{SVG}
@cindex vector graphics @subentry @acronym{API}
@cindex vector graphics @subentry @class{AbstractVectorCanvas}
@cindex vector graphics @subentry @class{MorphicCanvas}

The method names involved in the code above will look familiar to
users acquainted with @acronym{SVG, Scalable Vector
Graphic}@footnote{@url{https://en.wikipedia.org/wiki/SVG}}. It is
indeed inspired by its specifications, and it may serve as a loose
reference@footnote{@url{https://www.w3.org/TR/SVG11/}}. Nevertheless,
your first reference to look at regarding the available drawing
operations is the @class{AbstractVectorCanvas} class, then some bits of
its parent class, @class{MorphicCanvas}.

In this class, the methods are divided into two important categories:
the helper methods of the @label{drawing -} categories and the
fundamental Vector Graphics protocol in the @label{paths} &
@label{strokes} categories.

@figure{Method categories of the
@class{AbstractVectorCanvas},ch03-AbstractVectorCanvas,7}

In its @label{drawing - MorphicCanvas} category, observe how its helper
method, to draw a straight line, relates to the Vector Graphics
engine:

@smalltalkMethod{line: pt1 to: pt2 width: morphStrokeWidth color: aStrokeColor,
self strokeWidth: morphStrokeWidth color: aStrokeColor do: [
   self moveTo: pt1.
   self lineTo: pt2 ]}

In the @method{strokeWidth:color:do:} method above, the argument of
the @smalltalk{do:} keyword is the path followed by the sketch; it
describes the outline of the shape to construct. It blends very nicely
into the Smalltalk syntax as a block of code. Your drawing operations
should always be presented in such a block. Of course, it can be
factored into several smaller methods or iterative processes, making it
a very powerful means for drawing.

The @label{stroke & fill} method category shows the methods to adjust
the style of the path stroke. All in all, there are four categories of
parameters to play with:

@itemize
@item @strong{width.}
A floating-point number representing the width of the line.
@item @strong{color.}
The color of the stroke; it's a @cuis{} @class{Color} instance.
@item @strong{fill color.}
The filling color, a @class{Color} instance.
@item @strong{dash style.}
There are three different parameters to play with to represent the
style of the line.
@end itemize

@c explain the width and point arguments are float

To be able to use floating-point numbers instead of integers helps to
obtain smoother visual rendering. To illustrate it, let's turn our
simple cross into a flashing medical cross as seen above the
drugstore.

Let's copy the class as @class{MedicCross} and add a @smalltalk{width}
attribute:

@smalltalkExample{PlacedMorph subclass: #MedicCross
   instanceVariableNames: 'width'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'ArtOfMorph'}

We initialize it properly:

@smalltalkMethod{initialize,
super initialize.
width := 0}

@c extend the cross to make it pulse in its width
@cindex morph @subentry step
@cindex morph @subentry animation

To pulse the cross, we use the morphic's step mechanism, generally
involving 3 methods: in our @class{MedicCross} the @method{step}
method is continuously executed at a period in milliseconds indicated
by its @method{stepTime} method,

@smalltalkMethod{CrossMedic >> stepTime,
@return 10 }

then, to indicate we want the stepping to occur, its
@method{wantsSteps} method must return @smalltalk{true},

@smalltalkMethod{CrossMedic >> wantsSteps,
@return true }

@exercise{@method{step} method makes it pulse,medicCrossStep,
Implement the @method{step} method in @class{MedicCross} so that its
@smalltalk{width} increments by 0.2 until 30@comma{} then it is zeroed.}

@figure{A flashing medic cross,ch03-medicCross,3}

In the next section, we go a bit further by representing a real-world
object, a simple ruler.

@node Ruler
@section Ruler

@cindex morph @subentry @class{PlacedMorph}

Rulers come with different lengths; our morph ruler is a
@class{PlacedMorph}@footnote{It can be grabbed and moved around.} with
a @smalltalk{length} attribute:

@smalltalkExample{PlacedMorph subclass: #Ruler
   instanceVariableNames: 'length'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'ArtOfMorph'}

Our ruler is to be graduated with metric units, so we define our scale
between pixels and centimeters:

@smalltalkMethod{ppcm,
" pixels per cm "
^ 50.0}

To both ease reading of the graduations and to reveal as much as
possible the visuals underneath the ruler, it is painted in plain
color under the sticks and with transparency elsewhere.

@smalltalkMethod{drawOn: canvas,
| font extent |
font := FontFamily familyName: FontFamily defaultFamilyName pointSize: 8.
extent := length * self ppcm + (self ppcm / 2) @@ 60.

canvas fillRectangle: (-5 @@ 0 corner: extent x @@ 25) color: Color yellow.
canvas fillRectangle: (-5 @@ 25 corner: extent) color: (Color yellow alpha: 0.5).
canvas frameRectangle: (-5 @@ 0 corner: extent) borderWidth: 0.5
color: Color yellow muchDarker.
canvas strokeWidth: 0.8 color: Color black do: [
   0 to: length do: [:posX |
      canvas moveTo: posX * self ppcm @ 0.5; lineToY: 10.
      canvas moveTo: posX * self ppcm + (self ppcm / 2) @@ 0.5; lineToY: 6]].
   0 to: length do: [:posX |
      canvas drawString: posX asString
         atCenterX: posX * self ppcm @@ 12 font: font color: Color black]}

@figure{Ruler with a centimeter graduation,ch03-ruler1,7}

@cindex morph @subentry coordinates system

When drawing, the coordinates we are using are always considered as
part of a coordinate system local to the morph we are drawing
into. This makes the task both simple and powerful; we will be able to
benefit from this feature to implement smart user interactions. In the
method above, the zero on the ruler coincides with the origin in the
morph coordinate system.

@exercise{Avoid expensive calculus,avoidExpensiveCalculus,
The @method{drawOn:} method above is written to be compact and easy to
read; however the method @method{ppcm} is used extensively to convert
between centimeters and pixels@comma{} which implies numerous
multiplications and some divisions. These operations are more
expensive than additions. Rewrite @method{drawOn:} to avoid
multiplication and division@comma{} particularly in loops.}

@exercise{Millimeter graduation,millimeterRuler,
Our ruler should be graduated each millimeter as shown in the figure
below -- @ref{ch03-ruler2}. Extend the @method{drawOn:} to do so.}

@figure{Ruler with a millimeter graduation,ch03-ruler2,7}

@cindex morph @subentry handle @subentry rotation

Very likely, you have already noticed the ruler can be dragged around.
When activating its halo of handles -- @kbd{Alt-click} or
@kbd{middle-click} -- it rotates with the blue handle at its left
bottom position.

@figure{Rotating the ruler with its handle,ch03-rulerCenter1,7}

@cindex transformation @subentry rotation center

As you experience it, it is rotated around the center of its
bounding box. From the ruler inspector, interrogate the ruler about its
center:

@smalltalkExample{self rotationCenter
@result{} 260.9997510912408 @@ 29.999971389797793}

These coordinates are relative -- as always in the @cuis{} system --
to the ruler's own coordinate system. When pivoting the ruler, it will
be more practical if it rotates around its origin; this will ease doing
measurements on the screen. Fortunately, it is easy to adjust it:

@smalltalkMethod{Ruler >> rotationCenter,
@return `0@@0`}

It now rotates around this point!

Using the halo handle to rotate the ruler is not very practical; we
need a direct handle on the ruler to do so. In the next section, you
will learn how to compose our morph designed from scratch with
additional morphs.

@node Composing
@section Composing

What we want is a direct handle on the ruler to rotate it. It is just
a morph button to be inserted somewhere in the ruler, that's all we
need to do.

@smalltalkMethod{insertButtons,
| btn |
btn := ButtonMorph model: self action: #rotateRuler ::
   actWhen: #buttonStillDown;
   icon: Theme current refreshIcon;
   color: Color transparent;
   selectedColor: Color yellow darker;
   morphExtent: Theme current refreshIcon extent * 1.5.
self addMorph: btn.
btn morphPosition: length * self ppcm @@ 30}

@cindex morph @subentry owner

The button morph added to the ruler is positioned according to the
coordinate system of the ruler -- its @emph{owner}. Whenever it is
scaled or rotated later with its halo handles, its sub-morphs -- here
the buttons -- are positioned accordingly. We decide to place the
button at the end of the ruler; it is more practical when pivoting the
ruler. The button acts when the user keeps pressing the mouse button
down; the method @smalltalk{rotateRuler} is then called.

@cindex morph @subentry coordinates system @subentry conversion

In this method, we calculate the angle between two consecutive vectors
going from the ruler rotation center to the mouse positions. As the
mouse positions are in world coordinates, we ask for the ruler
rotation center -- also its origin -- to be converted into the world
coordinate system -- @smalltalk{self externalizeToWorld: self
rotationCenter}.

As we want both the angle and the direction of the user gesture --
upward or downward -- we want a signed angle. Therefore, we use the
vector product@footnote{@url{https://en.wikipedia.org/wiki/Cross_product#Definition}}
to deduce the angle between these two consecutive vectors. This angle
is then used to rotate the ruler accordingly.

@smalltalkMethod{rotateRuler,
| event p1 v1 v2|
"anything new to do?"
event := self activeHand lastMouseEvent.
event isMove ifTrue: [
   p1 := self externalizeToWorld: self rotationCenter.
   v1 := lastHandPosition - p1.
   lastHandPosition := event eventPosition.
   v2 := lastHandPosition - p1.
   (v1 isZero or: [v2 isZero]) ifTrue: [@return{} self].
   self rotateBy: ((v1 crossProduct: v2) / (v1 r * v2 r)) arcSin ]
ifFalse: [lastHandPosition := event eventPosition]}

You may want to take a second look at this method; it is a bit complex
at first, but it also exposes the wonderful design of @cuis{}'s Morph
3 to manage quite easily that kind of user interaction.

@figure{A handy button to rotate the ruler,ch03-rulerRotateButton,7}

Our next move is to give the ability to the user to change the length
of their ruler, the @smalltalk{length} attribute. Therefore, we insert
a second button to do so and in the process refactor the method:

@smalltalkMethod{insertButtons,
| btn buttonExtent |
buttonExtent := Theme current refreshIcon extent * 1.5.
btn := ButtonMorph model: self action: #rotateRuler ::
   actWhen: #buttonStillDown;
   icon: Theme current refreshIcon;
   color: Color transparent;
   selectedColor: Color yellow darker;
   morphExtent: buttonExtent.
self addMorph: btn.
btn := ButtonMorph model: self action: #resizeRuler ::
   actWhen: #buttonStillDown;
   icon: (Theme current fetch: #( '16x16' 'actions' 'go-last' ));
   color: Color transparent;
   selectedColor: Color yellow darker;
   morphExtent: buttonExtent.
self addMorph: btn.
self positioningButtons }

As the @smalltalk{length} varies, so does the morph width; therefore
it makes perfect sense to have a distinct method to move the buttons
at the right place:

@smalltalkMethod{positioningButtons,
| buttonWidth position |
buttonWidth := submorphs first morphWidth.
position := length rounded * self ppcm -4 @@ 30.
submorphs do: [:btn |
   btn morphPosition: position.
   position := position translatedBy: -4 - buttonWidth @@ 0 ]}

Now the @method{resizeRuler} method to effectively change the length
of the ruler looks a bit similar to @method{rotateRuler} in its
general shape. But there are subtle differences to benefit from the
Morph 3 design.

@smalltalkMethod{resizeRuler,
| event prev |
"anything new to do?"
event := self activeHand lastMouseEvent.
event isMove ifTrue: [
   prev := lastHandPosition.
   lastHandPosition := self internalizeFromWorld: event eventPosition.
   self length: length + (lastHandPosition x - prev x / self ppcm)]
ifFalse: [lastHandPosition := self internalizeFromWorld: event eventPosition]}

@cindex morph @subentry coordinates system @subentry conversion

When the user keeps pressing the resize button, the ruler should
shrink when the mouse pointer moves in direction of the smallest value
of the ruler x-axis and its length should increase when the mouse
pointer moves in direction of the greatest value of its x-axis.

To be able to determine these behaviors of the mouse pointer, the
pointer coordinates -- expressed in the world coordinates system --
must be converted in the local coordinates system of the ruler. This
is exactly what is done by internalizing the mouse position
@smalltalk{self internalizeFromWorld: event eventPosition}. Then, the
abscissa delta between the two last mouse positions is calculated to
determine the change to the ruler length. And because we are doing
this calculus in the ruler coordinates system, it works whatever its
pivoted state.

@figure{A handy button to resize the ruler,ch03-rulerResizeButton,4}

Of course, when the length is adjusted, the positions of the buttons
is recomputed and the ruler is flagged to be redrawn:

@smalltalkMethod{length: newLength,
length := newLength max: 1.
self positioningButtons.
self redrawNeeded }

Because the @method{drawOn:} expects an integer value for the
@smalltalk{length}, a method variable @smalltalk{roundedLength} is set
to its rounded value and used instead in the remaining of the method:

@smalltalkMethod{drawOn: canvas,
| font grad posX extent step roundedLength |
font := FontFamily familyName: FontFamily defaultFamilyName pointSize: 8.
roundedLength := length rounded.
extent := roundedLength * self ppcm + (self ppcm / 2) @@ 60.
../..}

We end here our journey in the world of Morph. We hope this booklet
gives you enough insight and know-how to deepen your understanding and
start your own project. Developing small or large projects with the
@cuis{} system and its Morph 3 framework is very gratifying, have fun
in your project!
